---
globs: *.ts,*.js
alwaysApply: false
---
  
# TypeScript/JavaScript Patterns

## Import Organization

```typescript
// 1. Node.js built-ins
import fs from 'fs'
import path from 'path'

// 2. Third-party libraries
import { Command, Flags } from '@oclif/core'
import inquirer from 'inquirer'

// 3. Local imports (relative paths)
import { ApiAuth } from '../auth/ApiAuth'
import { fetchProjects } from '../api/projects'
```

## Class Structure

```typescript
export default class MyCommand extends Base {
    static description = 'Command description'
    static flags = {
        ...Base.flags,
        // Command-specific flags
    }
    
    // Properties
    authRequired = false
    
    // Main run method
    async run(): Promise<void> {
        // Implementation
    }
}
```

## Type Definitions

- Use interfaces for data structures
- Prefer `type` for unions and utilities
- Use Zod schemas for validation
- Export types from dedicated files

## Type Safety and Avoiding `any`

- **NEVER use `any` casting to fix TypeScript errors** - this defeats the purpose of TypeScript
- Instead of `as any`, find the root cause and fix it properly:
  - Update type definitions to be more accurate
  - Use proper type guards and narrowing
  - Add missing properties to interfaces
  - Use union types for flexible typing
  - Create proper type assertions with specific types

```typescript
// ❌ Wrong - using any to bypass TypeScript
const result = (someValue as any).property

// ✅ Correct - fix the underlying type issue
interface ProperType {
    property: string
}
const result = (someValue as ProperType).property

// ✅ Or use type guards
if ('property' in someValue) {
    const result = someValue.property
}
```

- When working with external libraries, use the type definitions from the library
- Use `unknown` instead of `any` when you genuinely don't know the type
- Prefer type narrowing over type assertions
- **If you cannot fix a TypeScript issue directly**, propose potential solutions to the user:
  - Explain what the type error means
  - Suggest multiple approaches to fix it properly
  - Identify if the issue is in type definitions, API design, or usage
  - Recommend the most appropriate solution based on the context

## Error Handling

```typescript
// Throw descriptive errors
throw new Error('Clear error message')

// Handle async errors
try {
    await apiCall()
} catch (error) {
    this.writer.showError(error.message)
    throw error
}
```

## Async/Await Patterns

- Always use async/await over Promises
- Handle errors with try/catch
- Use proper typing for async functions
- Avoid callback-based patterns

## Configuration Management

```typescript
// Environment variables
const clientId = process.env.DEVCYCLE_CLIENT_ID || flags['client-id']

// YAML configuration
const config = jsYaml.load(fs.readFileSync(configPath, 'utf8'))
```

## Validation

- Use Zod for runtime validation
- Use class-validator for class-based validation
- Validate user inputs before API calls
- Provide clear validation error messages

## Naming Conventions

- camelCase for variables and functions
- PascalCase for classes and interfaces
- SCREAMING_SNAKE_CASE for constants
- kebab-case for CLI flags and file names
