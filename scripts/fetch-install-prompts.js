#!/usr/bin/env node
/*
 * Auto-generates src/mcp/tools/installGuides.generated.ts
 * by listing all Markdown files under install-prompts/ (recursively)
 * from the AI-Prompts-And-Rules repo on the main branch.
 *
 * Includes OpenFeature guides automatically.
 */

const https = require('https')
const fs = require('fs')
const path = require('path')

// Keep a single constant for clarity and reuse
const TREE_URL = 'https://api.github.com/repos/DevCycleHQ-Sandbox/AI-Prompts-And-Rules/git/trees/main?recursive=1'

function fetchJson(url, headers = {}) {
    const requestHeaders = {
        'User-Agent': 'devcycle-cli-build-script',
        Accept: 'application/vnd.github+json',
        ...headers,
    }
    return new Promise((resolve, reject) => {
        const req = https.get(url, { headers: requestHeaders }, (res) => {
            let data = ''
            res.on('data', (chunk) => (data += chunk))
            res.on('end', () => {
                if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                        resolve(JSON.parse(data))
                    } catch (err) {
                        reject(err)
                    }
                } else {
                    reject(new Error(`HTTP ${res.statusCode}: ${data}`))
                }
            })
        })
        req.on('error', reject)
        req.end()
    })
}

async function main() {
    const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN
    const headers = token ? { Authorization: `Bearer ${token}` } : {}

    const outFile = path.resolve(
        __dirname,
        '..',
        'src',
        'mcp',
        'tools',
        'installGuides.generated.ts',
    )

    try {
        const tree = await fetchJson(TREE_URL, headers)
        const all = Array.isArray(tree.tree) ? tree.tree : []

        // Validate and sanitize file paths returned by GitHub API
        const isValidPath = (filePath) => {
            return (
                typeof filePath === 'string' &&
                filePath.length > 0 &&
                !filePath.includes('..') &&
                !path.isAbsolute(filePath) &&
                filePath.startsWith('install-prompts/') &&
                /^[a-zA-Z0-9_.\-\/]+$/.test(filePath)
            )
        }

        const mdFiles = all
            .filter((item) => item.type === 'blob')
            .map((item) => item.path)
            .filter(isValidPath)
            .filter((p) => p.toLowerCase().endsWith('.md'))

        // Build safe slugs (relative paths within install-prompts without extension)
        const slugSet = new Set()
        for (const p of mdFiles) {
            const raw = p.replace(/^install-prompts\//, '').replace(/\.md$/i, '')
            // extra guards on the slug
            if (!raw || raw.includes('..') || raw.startsWith('/')) continue
            const cleaned = raw
                // allow only safe characters (letters, numbers, dash, underscore, slash)
                .replace(/[^a-zA-Z0-9_\-\/]/g, '')
                // collapse multiple slashes
                .replace(/\/+/, '/')
                // trim leading/trailing slashes
                .replace(/^\/+|\/+$/g, '')
            if (cleaned) slugSet.add(cleaned)
        }

        const slugs = Array.from(slugSet).sort((a, b) => a.localeCompare(b))

        const content = `// AUTO-GENERATED BY scripts/fetch-install-prompts.js. DO NOT EDIT.
export const INSTALL_GUIDES = ${JSON.stringify(slugs, null, 2)} as const
export type InstallGuideId = typeof INSTALL_GUIDES[number]
`

        fs.writeFileSync(outFile, content, 'utf8')
        console.log(
            `Generated ${outFile} with ${slugs.length} install guide entries.`,
        )
    } catch (err) {
        const message = `[fetch-install-prompts] Failed to generate guides list: ${
            err && err.message ? err.message : err
        }`
        if (fs.existsSync(outFile)) {
            console.warn(
                `${message}. Existing generated file found at ${outFile}. Proceeding with previously generated data.`,
            )
            return
        }
        // No previously generated file; fail immediately.
        throw new Error(
            `${message}. No existing generated file found. Cannot proceed.`,
        )
    }
}

main()
    .then(() => {})
    .catch((err) => {
        console.error(err)
        process.exit(1)
    })


